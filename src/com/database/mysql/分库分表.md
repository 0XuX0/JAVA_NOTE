### 分库分表

分库分表就是为了解决由于数据量过大而导致数据库性能降低的问题，将原来独立的数据库拆分成若干数据库组成，将数据大表拆分成若干数据表组成，使得单一数据库、单一数据表的数据量变小，从而达到提升数据库性能的目的

##### 分库

由于一台服务器的资源是有限的，当业务量不断地增大，面对高并发的读写访问，master服务器无法承载写操作压力，需要通过分库策略，把原本存储于一个库的数据分块存储到多个库上，提高数据库并发访问能力。

##### 分表

当业务量不断地增大，单表的数据量不断增大，增删改查的开销会越来越大，垂直或水平的分表策略能够解决单表数据量过大带来的操作效率下降问题

### 分库分表方案

##### 垂直分表

​	以字段为依据，把一个宽表的字段按活跃性或是否是大字段的原则拆分为多个表，通常有字段冗余，这样既能使业务清晰，还能提升部分性能。拆分后尽量从业务角度避免联查，否则性能方面将得不偿失。

###### 举例

商品表A[id name price] 商品描述表B[id description]

用户浏览商品列表时，只对某商品感兴趣时才会查看其详细描述。因此商品描述字段访问频次较低，且该字段存储占用空间较大，访问单个数据IO时间较长；商品信息中名称价格等其他字段访问频次高

###### 提升

1. 为避免IO争抢并减少锁表的几率，查看详情的用户与商品信息浏览互不影响
2. 充分发挥热门数据的操作效率，商品信息的操作高效率不会被商品描述的低效率拖累

##### 垂直分库

​	以表为依据，把多个表按业务耦合松紧归类，分别存放到不同的库，这些库可以分布在不同服务器，从而使访问压力被多服务器负载，大大提升性能，同时能提高整体架构的业务清晰度，不同的业务库可根据自身情况定制优化方案。但是它需要解决跨库带来的所有复杂问题。

###### 举例

库内垂直分表方案中，数据始终限制在一台服务器，只解决了单一表数据量过大的问题，每个表还是竞争同一个物理机的CPU、内存、网络IO、磁盘。故而可以从业务角度考虑，把SELLER_DB(卖家库) 拆分为 PRODUCT_DB(商品库) STORE_DB(店铺库) 并把这两个库分散到不同服务器

###### 提升

1. 解决业务层的耦合，业务清晰
2. 能对不同业务的数据进行分级管理、维护、监控、扩展
3. 高并发场景下，提升一定的IO、数据库连接数等瓶颈

##### 水平分库

​	以字段为依据，可以把一个表的数据按照一定规则分到多个不同的库，每个库只有这个表的部分数据，这些库可以分布在不同服务器，从而使访问压力被多服务器负载，大大提升性能。其不仅需要解决跨库带来的所有复杂问题，还要解决数据路由的问题

###### 举例

在垂直分库方案中，数据库性能问题得到一定程度解决，但是随着业务量的增长，PRODUCT_DB 单库存储数据已经超出预估。且该库属于访问非常频繁的资源，单台服务器已经无法支撑。

将商品ID为单数的和商品ID为偶数的商品信息分别放在两个库中

###### 提升

1. 解决了单库大数据，提升高并发的性能瓶颈
2. 提高了系统的稳定性及可用性

##### 水平分表

​	以字段为依据，可以把一个表的数据分到同一个数据库的多张表中，每个表只有这个表的部分数据，这样可以小幅提升性能。

###### 举例

将商品信息表的数据，利用商品ID的hash结果为奇数或者偶数，分散到不同的表中

###### 提升

1. 优化单一表数据量过大而产生的性能问题
2. 避免IO争抢并减少锁表的几率
3. 库内的水平分表，解决单一表数据量过大的问题，提高检索性能

### 常见的分库分表中间件 

+ Sharding-JDBC
+ MyCat

|                | Sharding-JDBC          | MyCat                     |
| -------------- | ---------------------- | ------------------------- |
| 工作层面       | JDBC协议               | MySQL协议/JDBC协议        |
| 运行方式       | Jar包，客户端          | 独立服务，服务端          |
| 开发方式       | 代码/配置改动          | 连接地址(数据源)          |
| 性能           | 多线程并发操作，性能高 | 独立服务+网络开销         |
| 适用操作       | OLTP                   | OLTP+OLAP                 |
| 支持语言       | Java                   | 支持JDBC协议的语言        |
| 动态调整数据源 | 需自己实现             | 添加新组合配置并重启mycat |

### 分库分表可能遇到的问题

1. 事务问题

   + TCC
   + 最大努力通知
   + 可靠消息服务

2. 跨库join问题

   + 全局表：有可能系统中所有模块都会依赖到的一些表，类似于“数据字典”，可以将这类表在每个数据中均保存一份。这类数据很少发生修改，无需担心一致性问题

   + 字段冗余：“订单表” 中保存 “卖家Id” 的同时，也将卖家的 “Name” 字段冗余

     字段冗余是空间换时间的体现，但适用于依赖字段较少的场景，但需要考虑数据一致性的问题(卖家修改了name是否需要同步更新)，可借助业务代码层面去保证，当然结合实际场景看一致性的要求。

   + 系统层面封装：在不同数据库节点把符合条件的数据查询出来，然后重新组装

3. 跨节点的 count，order by，group by 以及聚合函数问题

   分别在各个节点上得到结果后在应用程序端进行合并

4. ID问题

   + UUID
   + Snowflake
   + 利用Redis做自增策略
   + 号段模式

### 订单表按照订单ID分库分表之后，如何根据其他字段进行高性能查询

##### ES构建二级索引

可以将所需进行判断的字段(where语句中进行判断的字段)，以及分库分表的分片字段，存进ES中，构建一个二级索引，每次查询的时候先在ES中进行查询，获取到订单ID，然后再根据订单ID去MySQL执行查询，类似于回表操作

##### ES存储全部字段

可以将数据表的全部字段及数据再存储一份到ES，查询的时候直接查询ES，无需再查询数据库，缺点是ES中存储的数据会很多

##### Mysql与ES中数据的增删改如何保证事务

###### 订阅binlog

基于阿里开源的canal订阅MySQL的binlog，把数据近实时同步到ES中，ES端自行保证幂等性

###### 编程式事务+补偿

回滚MySQL数据后自行控制回滚ES，若ES发生故障，可将写入ES失败的数据写入MySQL中，然后构建一个Worker任务定时扫描做补偿

###### 适用消息都列同步更改数据库

适用消息队列来传输数据的更改，但需保证消息的有序消费，构造同一行数据的增删改乱序，也会导致数据错乱。

##### 弊端

1. 数据不一致
   1. 数据同步需要时间
   2. 数据写入到ES后，保存进去的数据不能立即被查询到，需要等待刷新周期(1s)
2. 如果借助canal或者消息队列这种中间件出现故障，则需要有降级的手段

##### 借助Redis存储二级索引缓存

### MySQL对于千万级大表的优化思路

1. 优化sql和索引
2. 加缓存 memcached redis
3. 主从复制，读写分离
4. 使用mysql自带分区表，sql语句的条件中要带上分区条件的列，从而使查询定位到少量分区上
5. 垂直拆分
6. 水平切分
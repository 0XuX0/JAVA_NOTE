## MySQL 锁的概念

#### 悲观锁

悲观锁认为被它保护的数据是极其不安全的，每时每刻都有可能变动，一个事务拿到悲观锁后，其他任何事务都不能对该数据进行修改，只能等待锁被释放才可以执行。

> 悲观锁认为数据修改产生冲突的概率比较大，故在更新之前，我们需显示地对要修改的记录进行加锁，直到自己修改完再释放锁。加锁期间只有自己可以进行读写，其他事务只能读不能写。

#### 乐观锁

乐观锁认为数据的变动不会太频繁。因此它允许多个事务同时对数据进行变动，通常使用版本或时间戳来实现

> 乐观锁认为数据修改产生冲突的概率并不大，多个事务在修改数据之前需先查出版本号，在修改时把当前版本号作为修改条件，只会有一个事务可以修改成功，其他事务则会失败。

#### 共享锁与排他锁

+ 共享锁（S锁）：允许持锁事务读取一行
+ 排他锁（X锁）：允许持锁事务更新或者删除一行

若事务 T1 持有行 r 的 s 锁，当另一个事务 T2 请求 r 的 s 锁时，T1 T2都会持有 r 行的 s 锁，T2请求 r 的 x 锁时，T2需等待 T1 释放；

若事务 T1 持有行r 的 x 锁，当另一个事务 T2 请求 r 的 x 、s 锁时，T2 都必须等待 T1 释放

```mysql
select * from table where id = 1 for update; // 排他锁
select * from table where id = 1 lock in share mode; // 共享锁
```

Innodb 在SQL使用索引时，会用行级锁，在SQL未使用索引时，使用表级锁

select xxx where id = 1 lock in share mode;

update xxx set xx where id = 2; 条件非索引会被阻塞

#### 记录锁

+ 记录锁是最简单的行锁，仅仅锁住一行。如 SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE
+ 记录锁永远都是加在索引上，会阻塞其他事务对其插入、更新、删除

#### 间隙锁

+ 间隙锁是一种加在两个索引之间的锁，或者是第一个索引之前或者最后一个索引之后的间隙

+ 间隙锁锁住的是一个区间 ？

+ 间隙锁只阻止其他事务插入到间隙中，他们不阻止其他事务在同一个间隙上获得间隙锁 ？

  间隙锁的出现主要集中在同一个事务先delete后insert的情况下，当我们去删除一条记录的时候，如果数据库中存在，那么是普通行锁，锁住记录，然后删除，释放锁。如果这个记录不存在，数据库会扫描索引，向左扫描到第一个比给定参数小的值，向右扫描到第一个比给定参数大的值，然后以此为界，构建一个区间，锁住整个区间内的数据。

#### Next - Key Locks

+ Next - key 锁是记录锁和间隙锁的组合，指的是加在某条记录以及这条记录前面间隙上的锁

  在RR可重复读级别下，以下操作会触发next-key lock

  ```
  select .. for update
  select .. in share mode
  update 
  insert
  delete
  ```

  > 普通索引 锁左不锁右 [a,b)
  >
  > 唯一索引 锁右不锁左 (a,b]

  普通索引

  + =

    假设 = x 无论x这条记录是否在表中，都是锁上相邻记录

  + in

    本质上是把每个值，作为单独的一个等值查询操作，再把产生的锁定范围求并集

  + 比较符号 < <= > >=

    假设 < x ，若 x 存在于表中，则以其作为右边界，否则往增大方向找第一条记录作为右边界

    假设 <= x，找增大方向的下一条记录作为右边界

  + between

    等价于 a <= x <= b

#### 全局锁

对整个数据库实例加锁，MySQL提供加全局读锁的方法：Flush tables with read lock(FTWRL)

该命令可以使整个库处于只读状态。该命令之后，数据更新语句、数据定义语句等操作会被阻塞。

使用场景：全库逻辑备份(把整库每个表都select出来存成文本)

风险：

+ 如果在主库备份，备份期间不能更新，业务停摆
+ 如果在从库备份，备份期间不能执行主库同步过来的binlog，导致主从延迟

官方自带的逻辑备份工具mysqldump，当mysqldump使用参数--single-transaction的时候，会启动一个事务，确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。一致性读是好，但是前提是引擎要支持这个隔离级别，否则只能使用FTWRL方法。

#### 表级锁

MySQL里面表级锁有两种，一种是表锁，一种是元数据锁(meta data lock,MDL)
表锁的语法是:lock tables ... read/write。可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。

MDL：不需要显式使用，在访问一个表的时候会被自动加上。
MDL的作用：保证读写的正确性。
在对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。
读锁之间不互斥。读写锁之间，写锁之间是互斥的，用来保证变更表结构操作的安全性。
MDL 会直到事务提交才会释放，在做表结构变更的时候，一定要小心不要导致锁住线上查询和更新

#### 两阶段锁协议

在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。 ==> (如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放)

#### 死锁和死锁检测

当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。

出现死锁状态后，有两种策略：

+ 直接进入等待，直到超时。超时时间可以通过参数 innodb_lock_wait_timeout 来设置，默认50s
+ 发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑

由于第一种策略需等待的时间过长，而超时时间设置太小则会出现误伤其他事务，故而一般使用第二种策略，但是它也是有额外负担的。

每个信赖的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是个时间复杂度为O(n)的操作。假设有1000个并发线程要同时更新同一行，那么死锁检测操作就是100w量级。虽然最终检测的结果是没有死锁，但是期间要消耗大量的CPU资源。因此会看到CPU利用率很高，但是每秒却执行不了几个事务。

#### 热点行更新导致的性能问题

+ 拆行，一行拆多行 

  比如账户，可以考虑放在多条记录，比如10个记录，账户总额等于这10个记录的值的总和，每次给账户加金额的时候，随机选取其中一条记录来加。这样可以减少冲突概率，减少锁等待个数，减少死锁检测的CPU消耗

+ Server层限流，在进入引擎前排队，即同一时间进入更新的线程数
+ 关闭死锁检测
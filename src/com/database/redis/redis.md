## Redis

### 简单介绍一下Redis

Redis是一个使用C语言开发的内存数据库，读写速度非常快，被广泛引用于缓存，分布式锁。Redis提供了多种数据类型来支持不同的业务场景。Redis还支持事务、持久化、Lua脚本、多种集群方案

### Redis 于 Memcached 的区别和共同点

#### 共同点

1. 都是基于内存的数据库，一般都用来当做缓存使用。
2. 都有过期策略
3. 两者的性能都非常高

#### 区别

1. Redis支持更丰富的数据类型(支持更复杂的应用场景)。Memcached只支持最简单的kv数据模型
2. Redis支持数据持久化，可以将内存中的数据持久化至磁盘
3. Redis有灾难恢复机制。
4. Redis原生支持Cluster模式，Memcached需要依靠客户端来实现往集群中分片写入数据
5. Memcached是多线程、非阻塞IO的网络模型；Redis使用单线程的IO多路复用模型
6. Redis支持发布订阅模型、Lua脚本、事务等功能
7. Memcached 过期数据的删除策略只用了惰性删除，而Redis同时使用了惰性删除和定期删除

### 为什么用Redis / 为什么要用缓存

1. 高性能：内存的读速度远大于磁盘IO读取
2. 高并发：MySQL的qps大概在1w左右，Redis可以很容易达到10w+

### Redis 为什么这么快

1. 高效的数据结构
2. 基于内存
3. I/O多路复用模型

### Redis给缓存数据设置过期时间的作用

+ 缓解内存的消耗
+ 某些业务场景(比如短信验证码一分钟有效)

### 过期数据的删除策略

+ 惰性删除：只会在取出key的时候才对数据进行过期检查。对CPU友好但是可能会造成太多过期key没有被删除
+ 定期删除：每隔一段时间抽取一批key执行删除过期key操作。

Redis采用的是 **定期删除 + 惰性删除** (可能存在漏掉很多过期key的情况，导致OOM)

### Redis 内存淘汰机制

1. volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰
2. volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰
3. volatile-random：从已设置过期时间的数据集中任意选择数据淘汰
4. allkeys-lru：从数据集中移除最近最少使用的key(常用)
5. allkeys-random：从数据集中任意选择数据淘汰
6. no-eviction：禁止驱逐数据

### Redis 持久化

#### RDB(snapshotting)

Redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。在Redis.conf配置文件中默认有以下配置

``` 
save 900 1     #在900秒(15分钟)之后，如果至少有1个key发生变化，自动触发BGSAVE命令创建快照。
save 300 10    #在300秒(5分钟)之后，如果至少有10个key发生变化，自动触发BGSAVE命令创建快照。
save 60 10000#在60秒(1分钟)之后，如果至少有10000个key发生变化，自动触发BGSAVE命令创建快照。
```

#### AOF(append-only file)

与RDB持久化相比，AOF持久化的实时性更好。默认下没有开启aof，可通过以下参数开启

```
appendonly yes
```

开启AOF持久化后每执行一条会更改Redis中数据的命令，Redis就会将该命令写入磁盘中的aof文件。

Redis的配置文件中存在三种不同的AOF持久化方式

```
appendfsync always #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度
appendfsync everysec #每秒钟同步一次，显示地将多个写命令同步到硬盘
appendfsync no #让操作系统决定何时进行同步
```

#### AOF重写

在执行BGREWRITEAOF命令时，Redis服务器会维护一个AOF重写缓冲区，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令。当子进程完成创建新AOF文件的工作之后，服务器会将重写缓冲区中的所有内容追加到AOF文件的末尾，使得新旧两个AOF文件所保存的数据库状态一致。最后服务器用新的AOF文件替换旧的AOF文件。

### Redis 事务

+ MULTI：开启事务，redis会将后续命令逐个放入队列，然后使用EXEC命令来原子化执行
+ EXEC：执行事务中的所有操作命令
+ DISCARD：取消事务，放弃执行事务块中的所有命令
+ WATCH：监视一个或多个key，如果事务在执行前，这个key被其他命令修改，则事务被中断，不会执行事务中的任何命令
+ UNWATCH：取消WATCH对所有key的监视

#### Redis为什么不支持事务回滚

多数事务失败是由语法错误或者数据结构类型错误导致的，语法错误在入队前就进行检测，而类型错误是在执行时检测的，Redis为提升性能而采取这种简单的事务。

### 为什么Redis单线程却能支撑高并发

https://www.cnblogs.com/javazhiyin/p/10823768.html

### 缓存雪崩 

现象：缓存在同一时间大面积失效或缓存服务器宕机，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求

解决方案：

+ 事前：Redis高可用，主从 + 哨兵， Redis cluster，将数据均匀分布到不同节点，避免全盘崩溃
+ 事中：本地缓存 + hystrix限流&降级，避免数据库被打死 或者 key的时间加随机值
+ 事后：Redis持久化

### 缓存穿透

现象：每秒5000个请求中，其中4000个请求是黑客发出的恶意攻击，缓存和数据库中都查不到

解决方案：

1. 缓存无效key，并设置过期时间
2. 布隆过滤器，把所有可能存在的请求的值放在布隆过滤器中，若请求不存在布隆过滤器中，返回错误信息

### 缓存击穿

现象：少量的热点数据在失效的瞬间，大量的请求就击穿了缓存

解决方案：

+ 若缓存的数据基本不会发生更新，则将热点数据置为永不过期
+ 若缓存的数据更新不频繁，则可采用zk的分布式互斥锁，保证仅少量的请求能请求数据库并重新构建缓存
+ 若缓存的数据更新频繁，可利用定时线程在缓存过期前主动重新构建缓存或延后缓存过期时间，以保证所有的请求能一直访问到对应的缓存

### 如何解决Redis的并发竞争Key问题

ZK分布式锁

### 缓存数据库双写数据一致性

#### Cache Aside Pattern 旁路缓存模式

+ 读的时候先读缓存，缓存没有的话就读数据库，然后取出数据后放入缓存，同时返回响应
+ 更新的时候，先更新数据库，然后再删除缓存

为什么是删除缓存而不是更新缓存

a 缓存的内容需要经过比较复杂的数据计算

b 缓存中大量的冷数据，用到缓存才去计算

#### 如果删除缓存失败了会出现数据不一致情况，有何解决方案

先删除缓存，再更新数据库

存在的问题：高并发场景下，线程A更新的时候先把缓存删掉了然后去做更新数据库操作之前，线程B来读取数据，发现缓存没有数据，然后读取了数据库中的旧值放到了缓存中，然后A线程再去做更新数据库的操作

解决方案：

+ 先删缓存，再更新数据库，然后提交更新后再次删除缓存
+ 先删缓存，再更新数据库，然后使用内存队列保证串行化，使数据库更新完后再去读库

### Redis 主从架构

##### Redis同步

###### 全同步过程

+ Slave发送sync命令到Master
+ Master启动一个后台进程，将Redis中的数据快照保存到文件中
+ Master将保存数据快照期间接收到的写命令缓存起来
+ Master完成写文件操作后，将该文件发送给Slave
+ 使用新的RDB文件替换掉旧的RDB文件
+ Master将这期间收集的增量写命令发送给Slave端

###### 增量同步过程

+ Master接收到用户的操作指令，判断是否需要传播到Slave
+ 将操作记录以字符串的形式存储，追加到AOF文件
+ 将操作传播到其他Slave：1.对齐主从库 2.往响应缓存写入指令
+ 将缓存中的数据发送给Slave

### Redis哨兵机制

Redis sentinel是Redis官方提供的集群管理工具，是独立运行的进程，功能如下：

+ 监控：检查主从服务器是否正常
+ 提醒：通过API向管理员或其他应用程序发送故障通知
+ 自动故障迁移：主从切换

### Redis集群 一致性hash算法

#### 一致性hash算法：对2^32取模，将hash值空间组织成虚拟的圆环

对每台服务器的IP作hash函数映射，确定其在hash环上的位置

对数据key使用同样的hash函数进行映射，确定其在hash环上的位置，沿环顺时针第一台遇到的服务器就是目标存储节点

服务器宕机或新增服务器，都只需要重新定位环空间中的一小部分数据，具有较好的容错性和扩展性

#### Hash环数据倾斜问题

引入虚拟节点：对每个服务器计算多个hash值(ip + 数字)，在hash环上定位到多个虚拟节点，增加虚拟节点到实际节点的映射

### Redis存储对象信息是用Hash好还是String好

1. 介绍String和Hash的底层

2. 根据业务场景来选择

   String：

   + 每次需要访问大量的字段
   + 存储的结构具有多层嵌套

   Hash：

   + 在大多数情况中只需要访问少量字段
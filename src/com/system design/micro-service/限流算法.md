## 限流算法

### 固定窗口计数器算法

规定单位时间处理的请求数量。比如规定一个接口一分钟只能访问100次。

实现：给定一个变量 counter 来记录处理的请求数量，当 1 分钟内处理一个请求之后 counter + 1，1分钟内如果 counter = 100 的话，后续的请求就会被全部拒绝。等到 1 分钟结束后，将 counter 回归成0，重新开始计数。

该种限流算法无法保证限流速率，因而无法保证突然激增的流量。比如前半分钟一个请求都没有接收，后半分钟接收了很多请求。

![固定窗口计数器算法](pic\固定窗口计数器算法.png)

### 滑动窗口计数器算法

滑动窗口计数器算法相比于固定窗口计数器算法的优化在于：它把时间以一定比例分片。例如我们的接口限流是每分钟处理60个请求，我们可以把1分钟分为6个窗口，每隔10秒移动一次，每个窗口只能处理不大于 60 / 6 的请求，如果当前窗口的请求计数总和超过了限制的数量就不再处理其他请求

当滑动窗口的格子划分的越多，滑动窗口的滚动就越平滑，限流的统计就会越精确。

![滑动窗口计数器算法](pic\滑动窗口计数器算法.png)

### 漏桶算法

我们把发请求的动作比作成注水到桶中，我们处理请求的过程可以比喻为漏桶漏水。我们往桶中以任意速率流入水，以一定速率流出水。当水超过桶流量则丢弃，因为桶容量是不变的，保证了整体的速率。

实现：准备一个有界队列来保存请求，然后定期从队列中拿请求来执行

![漏桶算法](pic\漏桶算法.png)

### 令牌桶算法

桶里装的是令牌，请求需要获取一个令牌才能被处理，请求处理完毕后将令牌丢弃。我们根据限流大小，按照一定的速率往桶里添加令牌。

![令牌桶算法](pic\令牌桶算法.png)

实现方式：

+ 单机：并发工具类
+ 集群：redis + lua脚本
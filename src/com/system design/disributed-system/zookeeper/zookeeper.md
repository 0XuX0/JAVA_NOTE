## ZooKeeper

### 概览

ZooKeeper是一个开源的分布式协调服务，为使用者提供高可用、高性能、稳定的分布式数据一致性解决方案，通常被用于实现数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁和分布式队列等功能。

### 特点

+ 顺序一致性：从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到ZooKeeper中
+ 原子性：所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的
+ 可靠性：一旦一次更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖。

### 典型应用场景

+ 分布式锁：通过创建唯一节点获得分布式锁
+ 命名服务：可通过ZK的顺序节点生成全局唯一ID
+ 数据发布/订阅：通过Watcher机制实现。当数据发布到ZK被监听的节点上其他机器可通过监听ZK上节点的变化来实现配置的动态更新。

### 重要概念

#### Data model 数据模型

ZK数据模型采用层次化的多叉树形结构，每个节点上都可以存储数据。每个节点还可以拥有N个子节点，最上层根节点以“/”来代表。每个数据节点在ZK中称为znode，是ZK中数据的最小单元。且每个znode都有一个唯一的路径标识。

#### znode 数据节点

##### znode 类型

+ 持久(PERSISTENT)节点：一旦创建就一直存在即使ZK集群宕机，直到将其删除
+ 临时(EPHEMERAL)节点：临时节点的生命周期与客户端会话(session)绑定的，会话消失则节点消失。且临时节点只能做叶子节点。
+ 持久顺序(PERSISTENT_SEQUENTIAL)：除了具有持久节点的特性外，子节点的名称还具有顺序性。如 /node1/app0001 /node1/app0002
+ 临时顺序节点(EPHEMERAL_SEQUENTIAL)：除了具备临时节点的特性外，子节点的名称还具有顺序性。

##### znode数据结构

+ stat：状态信息，包括事务ID-cZxid、节点创建时间-cTime、子节点个数-numChildren等
+ data：节点存放的数据的具体内容

#### ACL(权限控制)

ZK采用ACL(AccessControlLists)策略来进行权限控制，类似UNIX文件系统的权限控制。ZK提供了以下五种操作权限：

+ CREATE：能创建子节点
+ READ：能获取节点数据和列出其子节点
+ WRITE：能设置/更新节点数据
+ DELETE：能删除子节点
+ ADMIN：能设置节点ACL的权限

#### Watcher 事件监听器

ZK允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，ZK服务端会将事件通知到感兴趣的客户端上去，该机制是ZK实现分布式协调服务的重要特性。

#### 会话 Session

Session 可看作是ZK服务器与客户端之间的一个TCP长连接，通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话也能够向ZK服务器发送请求并接受响应。

### ZK集群

#### ZK集群角色

+ Leader：既可以为客户端提供写服务又能提供读服务，负责投票的发起和决议，更新系统状态。
+ Follower：只能提供读服务，如果是写服务则转发给Leader，在选举中参与投票
+ Observer：只能提供读服务，但不能参与Leader 的选举过程，也不参与写操作的“过半写成功”策略，在不影响写性能的情况下提升集群的读性能

#### ZK集群中的服务器状态

+ LOOKING：寻找Leader
+ LEADING：Leader状态，对应的节点为Leader
+ FOLLOWING：Follower状态，对应的节点为Follower
+ OBSERVING：Observer状态，对应的节点为Observer

### ZAB协议

#### ZAB协议介绍

ZAB(ZooKeeper Atomic Broadcase 原子广播)协议是为分布式协调服务ZK专门设计的一种支持崩溃恢复的原子广播协议。ZK主要依赖ZAB协议来实现分布式数据一致性

#### ZAB 事务编号Zxid(事务请求计数器 + epoch)

Zxid是一个64位的数字，其中低32位是一个简单的单调递增的计数器，针对客户端每一个事务请求，计数器加1；高32位则代表Leader周期epoch的编号，每个当选产生一个新的Leader服务器，就会从这个Leader服务器上取出其本地日志中最大事务的Zxid，并从中读取epoch值然后加1，以此作为新的epoch，并将低32位从0开始计数

#### ZAB两种基本的模式

+ 崩溃恢复：当Leader服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB协议就会进入恢复模式并选举产生新的Leader服务器。当选举产生了新的Leader服务器。
+ 消息广播；当集群中已经有过半的Follower服务器完成了和Leader服务器的状态同步，那么整个服务框架就可以进入消息广播模式

#### ZAB的四个阶段

1. Leader election(选举阶段)：节点一开始都处于选举阶段，只要有一个节点得到超半数节点的票数便当选 准Leader
2. Discovery(发现阶段-接收提议、生成epoch、接受epoch)：followers跟准Leader进行通信，同步followers最近接收的事务提议。并且准Leader生成新的epoch，让followers接受，更新它们的accepted epoch
3. Synchronization(同步阶段)：利用准Leader前一阶段获得的最新提议历史，同步集群中所有的副本，只有当大多数节点同步完成之后准Leader才会成为真正的Leader
4. Broadcast(广播阶段)：ZK集群在该阶段可以正式对外提供事务服务，且Leader可以进行消息广播

#### ZAB投票机制

每个server首先给自己投票，然后用自己的选票和其他server做对比，权重大的胜出，使用权重较大的更新自身选票箱。具体的选举过程如下：

1. 每个server启动以后都询问其他Server投票给谁。对于其他server的询问，server每次根据自己的状态都回复自己推荐的leader的id和上一次处理事务的zxid(系统启动时每个server都会推荐自己)
2. 收到所有server回复以后，就计算出zxid最大的那个server，并将这个server相关信息置为下一次要投票的server
3. 计算这过程中获得票数最多的server为获胜者，如果获胜者的票数超过半数，则该server被选为leader。否则继续这个过程直到leader被选举出来
4. Follower连接leader，将最大的zxid发送给leader
5. Leader根据follower的zxid确定同步点，至此选举阶段完成
6. Leader与所有followers进行副本同步，并进入广播阶段

### 典型应用场景

1. 选主

   由ZK的强一致性，能够很好地保证在高并发的情况下保证节点创建的全局唯一性(即无法重复创建同样的节点)

   让多个客户端创建一个指定的临时节点，创建成功的就是master

   让其他不是master 的节点监听节点的状态，如果master挂了，会话就断了，节点会被删除，此时触发回调函数进行重新选举

2. 分布式锁

   让多个客户端同时创建一个临时节点，创建成功的说明获取到了锁。未获取到锁的客户端监听节点状态，如果互斥锁被释放可以调用回调函数重新获得锁

3. 命名服务

   如何给对象设置ID，ZK是通过树形结构存储数据节点的，对于每个节点的全路径，其必定是唯一的，以节点的全路径作为命名方式。

4. 集群管理和注册中心

   可以为每个机器创建临时节点，并监控其父节点，如果子节点列表有变动，那么可以使用在其父节点绑定的watcher进行状态监控和回调

   让服务提供者在zk中创建一个临时节点并将自己的ip port写入节点，当服务消费者需要进行调用时会通过注册中心找到相应的服务的地址列表，并缓存到本地。服务调用者添加监听器，如果临时节点改变则重新获取


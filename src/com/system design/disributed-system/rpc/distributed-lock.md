## 分布式锁

### Redis 分布式锁

官方名叫 RedLock 算法

+ 互斥(只能有一个客户端获取锁)
+ 不能死锁
+ 容错(只要大部分Redis节点创建了这把锁就可以)

#### Redis最普通的分布式锁

SET key value [EX seconds] [PX milliseconds] NX 创建一个key

+ NX：表示只有key不存在的时候才会设置成功，如果此时redis中存在这个key，那么设置失败，返回nil
+ EX seconds：设置key的过期时间，精确到秒级。意思是 seconds 秒后锁自动释放，别人创建的时候如果发现已经有了就不能加锁
+ PX milliseconds：设置key的过期时间，精确到毫秒级

比如执行以下命令：

```
SET resource_name random_value PX 30000 NX
```

释放锁就是删除 key，但是一般可以用 lua 脚本删除，判断 value 一样才删除

```java
-- 删除锁的时候，找到 key 对应的 value，跟自己传过去的 value 做比较，如果是一样的才删除。
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```

使用 random_value 随机值的原因：如果某个客户端获取到了锁，但是阻塞了很长时间才执行完，比如说超过了30s，此时可能已经自动释放锁，且别的客户端已经获取到了这个锁，此时直接删除 key 会有问题，所以得用随机值加 lua 脚本来释放锁。守护线程定时检测是否快要过期，请求是否延期。

但是在集群模式下，或Redis普通主从，那Redis主从异步复制，如果主节点挂了(key 没有了)，key还没同步到从节点，此时从节点切换为主节点，别人就可以 set key，从而拿到锁。

#### RedLock 算法

该场景是假设有一个Redis Cluster，有5个Redis master 实例。执行如下步骤获取一把锁

1. 获取当前时间戳，单位是毫秒
2. 轮流尝试在每个master节点上创建锁，过期时间较短，一般就几十毫秒
3. 尝试在大多数节点上建立一个锁，超过半数
4. 客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功
5. 要是锁建立失败，那么就依次将之前建立过的锁删除
6. 只要别人建立了一把分布式锁，你就得不断轮询去尝试获取锁

### ZK分布式锁

zk的某个节点尝试创建临时znode，此时创建成功就获取了这个锁；此时别的客户端来创建锁会失败，只能注册个Watcher来监听这个锁。释放锁就是删除这个znode，一旦释放掉就会通知客户端，然后其他等待的客户端就可以再次竞争加锁

### redis分布式锁和zk分布式锁的对比

+ redis分布式锁，需要自己不断尝试获取锁，比较消耗性能
+ zk分布式锁，获取不到锁，注册个监听器即可，性能开销较小